% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/easylegend.R
\name{setFactorGraphics}
\alias{setFactorGraphics}
\alias{setFactorGraphics.RasterLayer}
\alias{setFactorGraphics.default}
\alias{setFactorGraphics.matrix}
\title{Prepare a graphics and legend (col, pch, lty) from categorical data.}
\usage{
setFactorGraphics(x, ...)

\method{setFactorGraphics}{default}(x, col = FALSE, pch = FALSE,
  fill = FALSE, leg = NULL, ord = TRUE, decreasing = FALSE,
  naCol = "black", naPch = 25, naFill = "black", naLeg = "na", ...)

\method{setFactorGraphics}{matrix}(x, ...)

\method{setFactorGraphics}{RasterLayer}(x, ...)
}
\arguments{
\item{x}{A vector of numerical, character, boolean or factor values,
 representing categories (non-continuous, with a limited number
 of unique values).}

\item{col}{Logical value. If \code{TRUE}, a color will be attributed to
 each category in \code{x}, and the legend prepared for
 lines or symbols colors. Alternatively, can also be a vector
 of character strings representing R colors (see 'Color
 Specification' in \code{\link[graphics]{par}}), with one value
 per category in \code{x}. \bold{Should be in the same order as
 values in \code{unique(x)}}.}

\item{pch}{Logical value. If \code{TRUE}, a symbol will be attributed to
 each category in \code{x}. Alternatively, can also be a vector
 of point symbols, with one value per category in \code{x}.
 \bold{Should be in the same order as values in \code{unique(x)}}.}

\item{fill}{Logical value. If \code{TRUE}, a color will be attributed to
 each category in \code{x}, and the legend prepared for
 filled colors. Alternatively, can also be a vector
 of character strings representing R colors (see 'Color
 Specification' in \code{\link[graphics]{par}}), with one value
 per category in \code{x}. \bold{Should be in the same order as
 values in \code{unique(x)}}.}

\item{leg}{A vector of character strings with the label of each
 category in the legend. If \code{NULL}, legend's \code{legends}
 will be the same as \code{as.character(values)}.}

\item{ord}{Logical value. If \code{TRUE}, the legend is ordered (sorted).}

\item{decreasing}{Logical value. If \code{TRUE} (not default), and \code{ord = TRUE}
 the legend is ordered (sorted) in decreasing order (i.e. low
 values on the bottom of the color scale and high values on the
 top of the color scale).}

\item{naCol}{Single character string. Color for \code{NA} (missing) values.}

\item{naPch}{Single character string. Symbol for \code{NA} (missing) values.}

\item{naFill}{Single character string. Fill-color for \code{NA} (missing) values.}

\item{naLeg}{Single character string. Legend (label) for \code{NA} (missing)
 values.}

\item{\dots}{Additional parameters passed to specific methods.}
}
\value{
Returns a list of 3 \code{\link[base]{function}}:
 \code{col}, a function that converts \code{x}-like values into
 colors;
 \code{pch}, a function that converts \code{x}-like values into
 symbols;
 \code{legend}, a function to draw a legend on a plot with the
 correct colors and symbols. That function accepts \code{...}
 arguments, passed to the original \code{\link[graphics]{legend}}
 function.
}
\description{
Prepare a graphics and legend (col, pch, lty) from categorical data.
}
\examples{

# GENERATE DUMMY DATASET X-Y-Z OF CORRELATED VARIABLES + GROUPS
# =============================================================

#  Base variable (x) and groups (g)
n <- 200 
x <- rnorm( n ) 
g <- sample( x = c("a","b"), size = n, replace = TRUE ) 

#   y is a function of x and group and random noise
y <- 2*x + rnorm( n ) 
y[ g == "a" ] <- y[ g == "a" ] + 1
y[ g == "b" ] <- y[ g == "b" ] + 2

#   z is a function of x and random noise
z <- 3*x + rnorm( n ) 


#   Bind into a data.frame
xyz <- data.frame( "x" = x, "y" = y, "z" = z, "g" = g, 
    stringsAsFactors = FALSE )
rm( x, y, z, g )



# CATEGORY OVERLAY ON A X-Y PLOT (POINTS) AND REGRESSION LINE
# ===========================================================

library( "easylegend" ) 

#   'Calibrate' the legend
fg <- setFactorGraphics( x = xyz[, "g" ], col = TRUE, pch = TRUE )

#   Plot x y and g
plot( x = xyz[, "x" ], y = xyz[, "y" ], col = fg$col( xyz[, "g" ] ), 
    pch = fg$pch( xyz[, "g" ] ), panel.first = grid() )

#   Add regression lines
for( gi in unique( xyz[, "g" ] ) ){ 
    abline( lm( y ~ x, data = subset( xyz, g == gi ) ), col = fg$col( gi ) ) 
}   

#   Add legend
fg$legend( x = "bottomright", title = "Group:", bty = "n" )
fg$legend( x = "topleft", pch = NULL, lwd = 1, title = "Regression:", bty = "n" )

rm( fg )



# SAME, with MISSING GROUP-VALUES
# ===============================

xyz[ sample(x=1:n,size=round(n/5)), "g" ] <- NA

#   'Calibrate' the legend
fg <- setFactorGraphics( x = xyz[, "g" ], col = TRUE, pch = TRUE )

#   Plot x y and g
plot( x = xyz[, "x" ], y = xyz[, "y" ], col = fg$col( xyz[, "g" ] ), 
    pch = fg$pch( xyz[, "g" ] ), panel.first = grid() )

#   Add regression lines
abline( lm( y ~ x, data = subset( xyz, g == "a" )   ), col = fg$col( "a" ) ) 
abline( lm( y ~ x, data = subset( xyz, g == "b" )   ), col = fg$col( "b" ) ) 
abline( lm( y ~ x, data = subset( xyz, is.na( g ) ) ), col = fg$col( NA ) ) 

fg$legend( x = "bottomright", title = "Group:", bty = "n", lwd = 1 )

rm( fg )
}

