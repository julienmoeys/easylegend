% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/easylegend.R
\name{setColourScale}
\alias{setColourScale}
\alias{setColourScale.RasterLayer}
\alias{setColourScale.default}
\alias{setColourScale.matrix}
\title{Prepare colour scale and legend (col, fill) from continuous-numeric data.}
\usage{
setColourScale(x, ...)

\method{setColourScale}{default}(x, col = FALSE, fill = FALSE,
  breaks = NULL, naCol = "lightgray", naLeg = "na", brackets = c("",
  " ", ""), labels = NULL, right = FALSE, include.lowest = TRUE,
  digits = 3L, nsmall = 3L, decreasing = TRUE, y.intersp = 1.5,
  nBreaks = 6L, hideMinMax = c(FALSE, FALSE), ...)

\method{setColourScale}{matrix}(x, ...)

\method{setColourScale}{RasterLayer}(x, ...)
}
\arguments{
\item{x}{A vector of numerical values (continuous).}

\item{col}{Logical value or vector of character strings representing
 colours. If \code{TRUE} or vector of colours, a continuous
 colour scale is defined for 'x'. \code{col} and \code{fill}
 can't be set simultaneously (the corresponding legend would
 not work). \code{length(col)} must be equal to
 \code{length(breaks) - 1} or to \code{nBreaks - 1}
 (contrary to \code{\link{setColourRampScale}}).}

\item{fill}{Logical value or vector of character strings representing
 fill-colours. If \code{TRUE} or vector of colours, a
 continuous fill-colour scale is defined for 'x'. \code{col}
 and \code{fill} can't be set simultaneously (the
 corresponding legend would not work).
 \code{length(fill)} must be equal to
 \code{length(breaks) - 1} or to \code{nBreaks - 1}
 (contrary to \code{\link{setColourRampScale}}).}

\item{breaks}{See \code{\link[base]{cut}}. \code{length(breaks)} must
 be equal to \code{length(col) + 1} or
 \code{length(fill) + 1}. If \code{NULL}, \code{nBreaks}
 breaks will be generated internally (see below).
 \code{breaks} should be ordered (no \code{NA}), with no
 replica, and consistent with the argument \code{decreasing}.
 See \code{naCol} and \code{naLeg} regarding the handling
 of \code{NA}-values.}

\item{naCol}{Single character string. Colour for \code{NA} (missing)
 values. Notice that in the case of an
 \code{\link[graphics]{image}} plot this parameter is
 silently be ignored and replaced by \code{NA} as
 the function displays missing values as transparent pixels.
 In the case of \code{raster::plot}, One should make sure
 that the value of \code{naCol}-argument in
 \code{setColourRampScale} is coherent with the value of
 \code{naCol}-argument in \code{raster::plot}.}

\item{naLeg}{Single character string. Legend (label) for \code{NA}
 (missing) values.}

\item{brackets}{Vector of 3 characters. Used to generate customise
 legend-labels, if \code{labels} is \code{NULL}.}

\item{labels}{See \code{\link[base]{cut}}.}

\item{right}{See \code{\link[base]{cut}}.}

\item{include.lowest}{See \code{\link[base]{cut}}.}

\item{digits}{See \code{\link[base]{format}}. Number formatting in the
 legend.}

\item{nsmall}{See \code{\link[base]{format}}. Number formatting in the
 legend.}

\item{decreasing}{Logical value. If \code{TRUE} (default), the legend is
 ordered (sorted) in decreasing order (i.e. low values on
 the bottom of the colour scale and high values on the top
 of the colour scale).}

\item{y.intersp}{Single numerical value. Character inter-spacing factor
 for vertical (y) spacing of the colour legend. Passed to
 \code{\link[graphics]{legend}}.}

\item{nBreaks}{Single integer value. Number of breaks that must be
 generated internally when \code{breaks} is not specified
 (\code{NULL}). See argument \code{breaks} for details
  on how \code{nBreaks} and \code{col} or \code{fill}
 are related.}

\item{hideMinMax}{Vector of two logical value. If \code{TRUE}, the min or
 the max values in breaks (or both) will be replaced by
 \code{> x} or \code{< y} where \code{x} is the 2nd highest
 value in \code{breaks} and \code{y} is the 2nd smallest
 value in \code{breaks}. \code{hideMinMax[1L]} is for the
 min value and \code{hideMinMax[2L]} is for the max-value.}

\item{\dots}{Additional parameters passed to specific methods.}
}
\value{
Returns a list of 2 \code{\link[base]{function}}:
 \code{col} or \code{fill}, a function that converts
 \code{x}-like values into (fill)colours;
 \code{legend}, a function to draw a legend on a plot with
 the correct (fill)colours and legend. That function accepts
 \code{...} arguments, passed to the original
 \code{\link[graphics]{legend}} function.
}
\description{
Prepare colour scale and legend (col, fill) from
 continuous-numeric data. \code{setColourScale} is a
 partial rewriting of \code{\link{setColorScale}}.
}
\examples{

# GENERATE DUMMY DATASET X-Y-Z OF CORRELATED VARIABLES + GROUPS
# =============================================================

#  Base variable (x) and groups (g)
n <- 200 
x <- rnorm( n ) 
g <- sample( x = c("a","b"), size = n, replace = TRUE ) 

#   y is a function of x and group and random noise
y <- 2*x + rnorm( n ) 
y[ g == "a" ] <- y[ g == "a" ] + 1
y[ g == "b" ] <- y[ g == "b" ] + 2

#   z is a function of x and random noise
z <- 3*x + rnorm( n ) 


#   Bind into a data.frame
xyz <- data.frame( "x" = x, "y" = y, "z" = z, "g" = g, 
    stringsAsFactors = FALSE )
rm( x, y, z, g )

#   Missing group values
xyz[ sample(x=1:n,size=round(n/5)), "g" ] <- NA

#   Inspect the data.frame
head( xyz )



# X-Y PLOT WITH OVERLAY OF CONTINUOUS COLOR & CATEGORICAL SYMBOL 
# ==============================================================

library( "easylegend" )

#   'Calibrate' the legend
fg <- setFactorGraphics( x = xyz[, "g" ], pch = TRUE  )
cs <- setColourScale( x = xyz[, "z" ], fill = TRUE ) 

#   Plot x y and g
plot( x = xyz[, "x" ], y = xyz[, "y" ], col = cs$fill( xyz[, "z" ] ), 
    pch = fg$pch( xyz[, "g" ] ), panel.first = grid() )

#   Add legend
fg$legend( x = "bottomright", title = "Group:", bty = "n" )
cs$legend( x = "topleft",     title = "Z:",    bty = "n" )

rm( fg, cs )



# X-Y PLOT , CUSTOMISED
# =====================

#   'Calibrate' the legend (1)
fg <- setFactorGraphics( x = xyz[, "g" ], pch = 15:16 )

fill <- hsv( h = 0.21, s = .8, v = seq( .2, .8, length.out = 5 ) )

#   'Calibrate' the legend (2)
cs  <- setColourRampScale( x = xyz[, "z" ], fill = fill, int = 4, 
    nsmall = 1, digits = 1 ) 

#   Plot x y and g
plot( x = xyz[, "x" ], y = xyz[, "y" ], col = cs$fill( xyz[, "z" ] ), 
    pch = fg$pch( xyz[, "g" ] ), panel.first = grid() )

#   Add legend
fg$legend( x = "bottomright", title = "Group:", bty = "n" )
cs$legend( x = "topleft", title = "Z:", bty = "n" ) # , style = 1

rm( fg, cs, fill ) 



# X-Y PLOT, MISSING Z-VALUES (with intermediate colours)
# =====================================================

xyz[ is.na(xyz[, "g" ]), "z" ] <- NA

#   'Calibrate' the legend
cs <- setColourRampScale( x = xyz[, "z" ], int = 4 ) 

#   Plot x y and g
plot( x = xyz[, "x" ], y = xyz[, "y" ], col = cs$fill( xyz[, "z" ] ), 
    pch = 16, panel.first = grid() )

#   Add legend
cs$legend( x = "topleft", title = "Z:",    bty = "n" )

rm( cs )

#   Note: See the same test without intermediate colours 
#   below



# MATRIX AS COLORED IMAGE
# =======================

m <- matrix( data = rnorm(8*10), 8, 10 ) 
cs  <- setColourScale( m, fill = TRUE ) 

image( x = m, col = cs[[ "iFill" ]], breaks = cs[[ "iBreaks" ]], 
    bty = "n" ) # , xlim = c(0,1.5), asp = 1

cs$legend( x = "topright", bg = gray(1,alpha=.5) )

rm( cs )



# MATRIX, CUSTOMISED
# ==================

cs  <- setColourRampScale( m, int = 4, nsmall = 1, digits = 1 ) 

par( "mar" = c( 5, 4, 4, 5 ) + .1 )

image( x = m, col = cs[[ "iFill" ]], breaks = cs[[ "iBreaks" ]], 
    bty = "n" ) # , xlim = c(0,1.5), asp = 1

plotAnywhere( cs$legend( x = "right", "title" = "Values" ) )

rm( cs )



# MATRIX WITH LARGE RANGE OF VALUES
# =================================

breaks <- c(100,10,1,0)
m <- matrix( 
    data = c( 
        runif( 300, breaks[2], breaks[1] ), 
        runif( 300, breaks[3], breaks[2] ), 
        runif( 300, breaks[4], breaks[3] ) ), 
    30, 30, byrow = TRUE ) 

#   Add missing values
m[ sample(1:nrow(m),3), sample(1:ncol(m),3) ] <- NA 


cs  <- setColourRampScale( m, fill = c( "darkred", "red", "orange", "lightyellow" ), 
    int = 4, breaks = breaks, digits = 0, nsmall = 0 ) 

#   Standard plot: CAN'T SEE ANYTHING
image( matrix2image( m ) ) 

par( "mar" = c(5.1, 4.1, 4.1, 6.1) ) 

image( x = matrix2image( m ), col = cs[[ "iFill" ]], breaks = cs[[ "iBreaks" ]], 
    bty = "n" ) 

plotAnywhere( expr = cs$legend( x = "right", bty = "n" ) )

rm( cs )



# MORE TESTS
# ==========

# X-Y PLOT, MISSING Z-VALUES (without intermediate colours)
# --------------------------------------------------------

#   'Calibrate' the legend
cs <- setColourScale( x = xyz[, "z" ], fill = TRUE ) 

#   Plot x y and g
plot( x = xyz[, "x" ], y = xyz[, "y" ], col = cs$fill( xyz[, "z" ] ), 
    pch = 16, panel.first = grid() )

#   Add legend
cs$legend( x = "topleft",     title = "Z:",    bty = "n" )

rm( cs )



# X-Y PLOT, MISSING Z-VALUES AND INFINTE BOUNDS
# ---------------------------------------------

breaks <- quantile( 
    x     = xyz[, "z" ], 
    na.rm = TRUE, 
    probs = seq( 1, 0, -.2 ) ) 

breaks[ c(1,length(breaks)) ] <- breaks[ c(1,length(breaks)) ] * 10

#   'Calibrate' the legend
fill <- hsv( 
    h = 0.21, 
    s = .8, 
    v = seq( .8, .2, length.out = length( breaks ) ) ) 

cs <- setColourRampScale( x = xyz[, "z" ], fill = fill, int = 4, 
    breaks = breaks, hideMinMax = c( TRUE, TRUE ) ) 

#   Plot x y and g
plot( x = xyz[, "x" ], y = xyz[, "y" ], col = cs$fill( xyz[, "z" ] ), 
    pch = 16, panel.first = grid() )

#   Add legend
cs$legend( x = "topleft",     title = "Z:",    bty = "n" )

rm( cs, fill, breaks )



# MATRIX, CUSTOMISED (2 CATEGORIES)
# ---------------------------------

m <- matrix( data = rnorm(8*10), 8, 10 ) 

cs  <- setColourRampScale( 
    x      = m, 
    fill   = c("darkred", "orange", "lightyellow"), 
    int    = 4, 
    breaks = c(max(m)*2,0,min(m)*2), 
    digits = 1, 
    nsmall = 1, 
    hideMinMax = c( TRUE, TRUE ) ) 

par( "mar" = c(5, 4, 4, 5) + .1 ) 

image( x = matrix2image( m ), col = cs[[ "iFill" ]], 
    breaks = cs[[ "iBreaks" ]], bty = "n", asp = 1 ) 

plotAnywhere( expr = cs$legend( x = "right", bty = "n" ) )

rm( cs )



# MATRIX, CUSTOMISED (3 CATEGORIES)
# ---------------------------------

cs  <- setColourRampScale( 
    x      = m, 
    fill   = c( "darkred", "red", "orange","lightyellow"), 
    int    = 4, 
    breaks = c(max(m)*2,1,-1,min(m)*2), 
    digits = 1, 
    nsmall = 1, 
    hideMinMax = c( TRUE, TRUE ) ) 

par( "mar" = c(5.1, 4.1, 4.1, 6.1) ) 

image( x = matrix2image( m ), col = cs[[ "iFill" ]], 
    breaks = cs[[ "iBreaks" ]], bty = "n", asp = 1 ) 

plotAnywhere( expr = cs$legend( x = "right", bty = "n" ) )

#   Extra legend in reverse order
cs2  <- setColourRampScale( 
    x      = m, 
    fill   = c( "lightyellow", "orange", "red", "darkred" ), 
    int    = 4, 
    breaks = c(min(m)*2,-1,+1,max(m)*2), 
    digits = 1, 
    nsmall = 1, 
    hideMinMax = c( TRUE, TRUE ), 
    decreasing = FALSE ) 

plotAnywhere( expr = cs2$legend( x = "bottomright", bty = "n" ) )

rm( cs, cs2 )



# MATRIX, MISSING VALUES
# ----------------------

#   Add missing values
m[ sample(1:nrow(m),3), sample(1:ncol(m),3) ] <- NA 

cs  <- setColourRampScale( m, int = 4, digits = 1, 
    nsmall = 1 ) 

par( "mar" = c(5.1, 4.1, 4.1, 6.1) ) 

image( x = matrix2image( m ), col = cs[[ "iFill" ]], 
    breaks = cs[[ "iBreaks" ]], bty = "n", asp = 1 ) 

plotAnywhere( expr = cs$legend( x = "right", bty = "n" ) )

rm( cs )

}
\seealso{
\code{\link{setColourRampScale}},
 \code{\link{setFactorGraphics}} and
 \code{\link[grDevices]{colorRampPalette}}.
}

